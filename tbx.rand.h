#ifndef TBX_RAND_H
#define TBX_RAND_H
//================================================================================
// "MIT License"
//================================================================================
// Copyright 2023 Michael J. Mannon
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//================================================================================

//======================================================================
// tbx.rand.h
//======================================================================
// This header provides drop-in replacements for functions std::rand() 
// and std::srand(seed) from standard library header <cstdlib>. 
// 
// When used without template arguments, rand() and srand(seed) 
// duplicate the interface and semantics of the corresponding functions 
// in <cstdlib>: 
// 
//   • tbx::rand() returns a pseudo-random int on the closed interval 
//     [0, tbx::rand_max()]. 
// 
//   • tbx::srand(seed) accepts an unsigned int as its argument, and 
//     uses it to seed the std::mt19937 random number engine that 
//     underlies rand().
// 
//   • tbx::rand() is implicitly seeded as if tbx::srand(1u) had been 
//     called. 
// 
// Template parameter ResultType controls the type of the random 
// numbers generated by rand(). It can be any of the types accepted 
// by std::uniform_int_distribution or std::uniform_real_distribution, 
// as well as their many type aliases from <cstdint>.
// 
// Here are some examples:
// 
//   • tbx::rand<short>()                 • tbx::rand<float>() 
//   • tbx::rand<unsigned long long>()    • tbx::rand<double>() 
//   • tbx::rand<std::int64_t>()          • etc.
// 
// Two non-standard overloads limit the range of values generated 
// by rand():
// 
//   • tbx::rand(a, b)       generate values on the integral range [a, b] 
//                           or the floating-point range [a, b)
// 
//   • tbx::rand(param)      "parameter" object of type 
//                           std::uniform_int_distribution::param_type 
//                           or std::uniform_real_distribution::param_type
// 
// Two non-standard overloads provide alternate seeding options, both 
// superior to srand(seed):
// 
//   • tbx::srand()          Use std::random_device to fill all 624 state 
//                           variables of std::mt19937. 
// 
//   • tbx::rand(seed_seq)   Use a std::seed_seq to fill all 624 state
//                           variables of std::mt19937. 
// 
// Behind the scenes, rand(), srand(seed) and rand_max(), along with 
// the four overloads described above, share a common random number 
// engine and distribution. 
// 
// The engine is std::mt19937. 
// 
// The distribution varies, depending on ResultType. For integral 
// types, the distribution is std::uniform_int_distribution. For 
// floating-point, std::uniform_real_distribution.
// 
// Thread Safe: All functions are "thread_local," meaning that each 
// thread where rand() is called has a random number engine and 
// distribution of its own. Threads that call functions in the rand() 
// family do not contend with other threads that use rand(), so no 
// locking is necessary. 
// 
// Lazy Initialization: The random number generator in a given thread 
// is not initialized until one of the functions in the rand() family 
// is called in that thread. Thus, you don't pay for what you don't use. 
// 
//======================================================================
// IMPORTANT NOTE: Any template argument used by rand() must also be 
// used by srand() and the other functions in the rand() family.
// 
// If, for instance, you generate random numbers using 
// tbx::rand<unsigned short>(), then you must seed the generator 
// using tbx::srand<unsigned short>() or one of its overloads. 
// Otherwise, you will seed a different engine from the one you intend. 
// 
// Each ResultType has its own random number engine. To select an 
// engine for seeding, you MUST provide its ResultType. The only 
// exception is when ResultType is int. Without a template arguemtnt, 
// srand() and its overloads default to seeding the random number 
// engine for type int.
//======================================================================

#include <cstddef>      // size_t
#include <random>       // mt19937, random_device, seed_seq, uniform_int_distribution, uniform_real_distribution
#include <sstream>      // stringstream
#include <type_traits>  // enable_if_t, integral_constant, is_floating_point_v, is_same_v, remove_cv_t

namespace tbx
{
    //==================================================================
    // is_integral_short_int_long
    //==================================================================
    template <typename T>
    struct is_integral_short_int_long : std::integral_constant
        < bool
        , std::is_same_v<std::remove_cv_t<T>, short>
        || std::is_same_v<std::remove_cv_t<T>, int>
        || std::is_same_v<std::remove_cv_t<T>, long>
        || std::is_same_v<std::remove_cv_t<T>, long long>
        || std::is_same_v<std::remove_cv_t<T>, unsigned short>
        || std::is_same_v<std::remove_cv_t<T>, unsigned int>
        || std::is_same_v<std::remove_cv_t<T>, unsigned long>
        || std::is_same_v<std::remove_cv_t<T>, unsigned long long>
        >
    {};
    template <typename T>
    bool constexpr is_integral_short_int_long_v
        = tbx::is_integral_short_int_long<T>::value;

    //==================================================================
    // is_arithmetic_short_int_long
    //==================================================================
    template <typename T>
    struct is_arithmetic_short_int_long : std::integral_constant
        < bool
        , tbx::is_integral_short_int_long_v<T> || std::is_floating_point_v<T>
        >
    {};
    template <typename T>
    bool constexpr is_arithmetic_short_int_long_v
        = tbx::is_arithmetic_short_int_long<T>::value;

    //==================================================================
    // uniform_distribution
    //==================================================================
    template <typename ResultType, typename = void>
    struct uniform_distribution
    {
        static_assert(tbx::is_integral_short_int_long_v<ResultType>);
        using type = std::uniform_int_distribution<ResultType>;
    };
    template <typename ResultType>
    struct uniform_distribution<ResultType, std::enable_if_t<std::is_floating_point_v<ResultType>>>
    {
        using type = std::uniform_real_distribution<ResultType>;
    };
    template <typename ResultType>
    using uniform_distribution_t = typename tbx::uniform_distribution<ResultType>::type;

    //==================================================================
    // param_type
    //==================================================================
    template <typename ResultType>
    using param_type = typename tbx::uniform_distribution_t<ResultType>::param_type;

    //==================================================================
    // rand_replacement
    //==================================================================
    template <typename ResultType>
    class rand_replacement
    {
        static_assert(tbx::is_arithmetic_short_int_long_v<ResultType>);
    public:
        using urbg_type = std::mt19937;
        using seed_type = typename std::mt19937::result_type;
        using distribution_type = tbx::uniform_distribution_t<ResultType>;
        using param_type = typename distribution_type::param_type;
        using result_type = ResultType;
    private:
        urbg_type eng_{ seed_type{1u} };  // By default, rand() uses seed 1u.
        distribution_type dist_;
    public:
        // Drop-in replacements for rand(), RAND_MAX, and srand(seed)
        auto rand()                          { return dist_(eng_); }
        auto rand_max()                      { return dist_.max(); }
        void srand(seed_type const seed)     { dist_.reset(); eng_.seed(seed); }

        // Non-standard overloads
        void srand()                         { dist_.reset(); seed_randomly(); }
        void srand(std::seed_seq const& seq) { dist_.reset(); eng_.seed(seq); }
        auto rand(param_type const& p)       { return dist_(eng_, p); }
        auto rand(result_type const a, result_type const b)
        {
            return dist_(eng_, make_param(a, b));
        }
    private:
        auto static constexpr make_param(ResultType const a, ResultType const b)
        {
            return param_type
            {
                a < b ? param_type{ a, b }
                : b < a ? param_type{ b, a }
                : tbx::is_integral_short_int_long_v<ResultType> ? param_type{ a, b }
                : throw std::invalid_argument(
                    "tbx::rand_replacement<ResultType>::make_param(a, b): "
                    "floating-point arguments require a != b")
            };
        }
        void seed_randomly()
        {
            std::random_device rd;
            std::stringstream ss;
            for (std::size_t i{ std::mt19937::state_size }; i--;)
                ss << rd() << ' ';
            ss >> eng_;
        }
    };

    //==================================================================
    // rr - "rand replacement"
    //==================================================================
    template <typename ResultType>
    inline auto& rr()
    {
        static_assert(tbx::is_arithmetic_short_int_long_v<ResultType>);
        static thread_local tbx::rand_replacement<ResultType> r;
        return r;
    }

    //==================================================================
    // rand(), srand(), etc.
    //==================================================================
    template <typename ResultType = int>
    inline auto rand()
    {
        static_assert(tbx::is_arithmetic_short_int_long_v<ResultType>);
        return tbx::rr<ResultType>().rand();
    }
    //------------------------------------------------------------------
    template <typename ResultType = int>
    inline auto rand(ResultType const a, ResultType const b)
    {
        static_assert(tbx::is_arithmetic_short_int_long_v<ResultType>);
        return tbx::rr<ResultType>().rand(a, b);
    }
    //------------------------------------------------------------------
    template <typename ResultType = int>
    inline auto rand(tbx::param_type<ResultType> const p)
    {
        static_assert(tbx::is_arithmetic_short_int_long_v<ResultType>);
        return tbx::rr<ResultType>().rand(p);
    }
    //------------------------------------------------------------------
    template <typename ResultType = int>
    inline auto rand_max()
    {
        static_assert(tbx::is_arithmetic_short_int_long_v<ResultType>);
        return tbx::rr<ResultType>().rand_max();
    }
    //------------------------------------------------------------------
    template <typename ResultType = int>
    inline void srand()
    {
        static_assert(tbx::is_arithmetic_short_int_long_v<ResultType>);
        tbx::rr<ResultType>().srand();  // seed randomly from std::random_device
    }
    //------------------------------------------------------------------
    template <typename ResultType = int>
    inline void srand(typename std::mt19937::result_type const seed)
    {
        static_assert(tbx::is_arithmetic_short_int_long_v<ResultType>);
        tbx::rr<ResultType>().srand(seed);  // seed from unsigned int
    }
    //------------------------------------------------------------------
    template <typename ResultType = int>
    inline void srand(std::seed_seq const& seq)
    {
        static_assert(tbx::is_arithmetic_short_int_long_v<ResultType>);
        tbx::rr<ResultType>().srand(seq);  // seed from std::seed_seq
    }
    //------------------------------------------------------------------
}   // end namespace tbx
#endif  // TBX_RAND_H
// end file: tbx.rand.h
